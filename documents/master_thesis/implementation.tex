\chapter{Implementation}
During this thesis I developed an application which is able to apply all the previously mentioned calculation methods for the load-flow calculation. Most of the application is written in \emph{C\#}, only \emph{HELM} is implemented as a \emph{C++}-library. This became necessary because of the superior abilities of templates over generics. I will give a more detailed explanation of these implementation details of the calculation methods in \secref{implementation_calculation_methods}.
As input formats are two options available: a custom format, stored in a \emph{MS SQL}-Database, and the format used by \emph{PSS SINCAL}. I will explain the implementation of the later one in \secref{link_sincal}. But before I discuss the implementation details I want to give you a short overview of the software architecture in the next section.

\section{Software Architecture}

\begin{figure}
	\centering
	\include{tikz/software_architecture}
	\caption{Overall software architecture}
	\label{fig:software_architecture}
\end{figure}

\begin{figure}
	\centering
	\include{tikz/calculation_architecture}
	\caption{Software architecture of the subsystem Calculation}
	\label{fig:calculation_architecture}
\end{figure}

The application is splitted into several subprojects, which build upon each other, as it can be seen in \figref{software_architecture}. The most important part is the Calculation, where the calculation methods are implemented. In \figref{calculation_architecture} this subproject is shown in detail; it is made out of hierarchical blocks too. This design has two big advantages: First of all, every single subsystem can be tested seperately, without the necessity to touch the other systems. Secondly, this design is more flexible. For instance, the consideration of unsymmetric situations could be achieved through three instances of a single phase net.

In \chapref{calculation_api} I show how the API of the Calculation subsystem can be used. For more complex examples I would like to refer to code of the unit tests.

\section{Calculation Methods}
\label{sec:implementation_calculation_methods}

\subsection{Holomorphic Embedding Load Flow}
For the implementation of the calculation methods I want to explain first the decision to implement \emph{HELM} in a separate library, written in \emph{C++}. Unfortunately, in some cases the mantissa of a 64 Bit floating point is not sufficient to benefit from the theoretical ideal convergence behaviour of \emph{HELM}. The problem here lies within the very small convergence radius of \eqref{helm_series}. As already mentioned before, the theoretical solution to this is an analytic continuation. At this point then the actual problem is buried, in \emph{Wynn's Epsilon Algorithm} only every second column is converging, the other columns between diverge. Approximately with 50 coefficients the divergence is already at the barrier of the precision of a 64 Bit floating point. The calculation of more coefficients does not improve the results anymore, because the numerical error, caused by the machine epsilon, is bigger than the possible gain in accuracy.

\begin{figure}
	\centering
	\include{tikz/convergence_border_net}
	\caption{Test net for convergence border}
	\label{fig:convergence_border_net}
\end{figure}

To give a more demonstrative explanation I want to show you the results of a comparison of the convergence behaviour of different algorithms. For this purpose I used the net \figref{convergence_border_net}, which is stable for $P \le \SI{0.25}{W}$. In this net I increased the power as long as the algorithm did converge and noted down the value closest to the border of stability. The result of this procedure is \figref{convergence_border}, in which it can be seen that a more accurate floating point enables \emph{HELM} to get closer to the border of stability. The use of \emph{HELM} with only 64 Bit for the initial voltages is already an improvement over the direct application of the \emph{Current Iteration} and \emph{Newton-Raphson}, in terms of convergence behaviour. But in the end, only \emph{HELM} with an arbitrary precise datatype is able to get as close as desired to the border of stability, although this advantage is traded in for a lot worse performance.

\begin{figure}
	\centering
	\includegraphics[scale=0.7]{figures/convergence_border}
	\caption{Convergence border for \figref{convergence_border_net}}
	\label{fig:convergence_border}
\end{figure}

To be able to evaluate \emph{HELM} in detail, also for critical nets, which can not be calculated with the iterative methods, I decided to implement \emph{HELM} with the possibility of a configurable precise datatype. As the generics in \emph{C\#} did not gave me the ability to use a library of precise datatypes together with a package for linear algebra, I decided to switch for this part of the application to \emph{C++}. In this language I had templates available, which allowed the combination of \emph{MPIR} \footnote{http://mpir.org/}, a library for multi precision integers and rationals, with \emph{Eigen} \footnote{http://eigen.tuxfamily.org/}, a library for sparse linear algebra. Through this I was able to reduce the necessity of reimplementing one of these essential and complex moduls.

\subsection{Linear Algebra}
All the implemented methods have one thing in common: linear algebra. In all these methods it is necessary to solve linear equation systems, although the equation systems differ in their properties. In \emph{HELM} and the \emph{Current Iteration} the system matrix is the admittance matrix, in \emph{Newton-Raphson} and \emph{FDLF} it is a Jacobian matrix. Both types of matrices are typically sparse, therefore the use of sparse linear algebra improves the performance of the algorithms significantly.

To solve these linear equation systems for instance with a LU-factorization is for big power nets unpractical, as only this step might take hours on current hardware. The solution to this is to use iterative solvers like \emph{BiCGSTAB} \cite{bicgstab}.

The last important detail of the implementation of the calculation methods is the preconditioning. With this step special properties of the system matrix can be used to improve the condition of the equation system, and therefore accelerate the iterative solvers. Fortunately, the admittance matrix, which is the system matrix in the \emph{Current Iteration} and \emph{HELM} is approximately diagonal dominant. This makes the application of a diagonal preconditioner very practical, because such a preconditioning is very efficient to calculate and improves the condition of the equation system significantly in this special case.

\section{Link to PSS SINCAL}
\label{sec:link_sincal}
The tool of choice in europe, especially at the Institute of Power Transmission Systems at the Technische Universität München, for load-flow calculations is \emph{PSS SINCAL}. Consequently, the tool developed during this thesis has a parser for this file format. This parser allows to read a power net from the file and write back the calculated node voltages.

The basic structure of a power net in \emph{PSS SINCAL} is as follows:
\begin{itemize}
	\item {\textlangle}name{\textrangle}.sin
	\item {\textlangle}name{\textrangle\_}files
	\begin{itemize}
		\item database.001.dia
		\item database.ini
		\item database.mdb
	\end{itemize}
\end{itemize}

The main information about the electrical characteristics of the power net are stored in the \emph{MS Access}-database. Fortunately, this database is documented very well online \footnote{http://sincal.s3.amazonaws.com/doc/Misc/SINCAL\_Datenbankinterface.pdf} and by the documents delivered together with the application.

The most important tables in this database are:
\begin{itemize}
	\item Terminal: contains information about the connection of the net elements with the nodes
	\item VoltageLevel: mostly used for the frequency of the power net
	\item Element: contains all net elements
	\item Node: contains all nodes with their ID, name, voltage level, ... etc.
	\item TwoWindingTransformer, ThreeWindingTransformer, Line, SynchronousMachine, Load, Infeeder: contain the corresponding net elements
	\item LFNodeResult: contains the node results of the load-flow calculation
\end{itemize}

For more detailed information about the database I would like to refer to the official documentation, or the implementation of the parser in the subsystem \emph{SincalConnector}.